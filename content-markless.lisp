;;;; guetor/content-markless.lisp

(defpackage :guetor/content-markless
  (:use :cl)
  (:import-from :plump *stream*)
  (:export #:output-markless))
(in-package :guetor/content-markless)

(defparameter *open-tag*
  '(("h1" . "# ")
    ("h2" . "## ")
    ("h3" . "### ")
    ("h4" . "#### ")
    ("h5" . "##### ")
    ("p" . "")
    ("cite" . "~~ ")
    ("li" . "- ")
    ("img" . "[ image ")
    ("audio" . "[ audio ")
    ("video" . "[ video ")
    ("strong" . " **")
    ("b" . " **")
    ("em" . " //")
    ("i" . " //")
    ("u" . " __")
    ("s" . " <-")
    ("code" . ":: ")
    ("pre" . "")
    ;; inside-li
    ("- p" . "")
    ("- strong" . " **")
    ("- b" . " **")
    ("- em" . " //")
    ("- i" . " //")
    ("- u" . " __")
    ("- s" . " <-")
    ;; inside-blockquote
    ("> h1" . "| # ")
    ("> h2" . "| ## ")
    ("> h3" . "| ### ")
    ("> h4" . "| #### ")
    ("> h5" . "| ##### ")
    ("> p" . "| ")
    ("> cite" . "~~ ")
    ("> li" . "| - ")
    ("> strong" . " **")
    ("> b" . " **")
    ("> em" . " //")
    ("> i" . " //")
    ("> u" . " __")
    ("> s" . " <-")
    ;; inside-blockquote-li
    ("> - p" . "")
    ("> - strong" . " **")
    ("> - b" . " **")
    ("> - em" . " //")
    ("> - i" . " //")
    ("> - u" . " __")
    ("> - s" . " <-")))

(defparameter *close-tag*
  '(("h1" . "~2&")
    ("h2" . "~2&")
    ("h3" . "~2&")
    ("h4" . "~2&")
    ("h5" . "~2&")
    ("p" . "~2&")
    ("cite" . "~&")
    ("li" . "~&")
    ("img" . " ]~&")
    ("audio" . " ]~&")
    ("video" . " ]~&")
    ("strong" . "** ")
    ("b" . "** ")
    ("em" . "// ")
    ("i" . "// ")
    ("u" . "__ ")
    ("s" . "-> ")
    ("code" . "::~2&")
    ("pre" . "~&")
    ;; inside-li
    ("- p" . "~&")
    ("- strong" . "** ")
    ("- b" . "** ")
    ("- em" . "// ")
    ("- i" . "// ")
    ("- u" . "__ ")
    ("- s" . "-> ")
    ;; inside-blockquote
    ("> h1" . "~&")
    ("> h2" . "~&")
    ("> h3" . "~&")
    ("> h4" . "~&")
    ("> h5" . "~&")
    ("> p" . "~&")
    ("> cite" . "~&")
    ("> li" . "~&")
    ("> strong" . "** ")
    ("> b" . "** ")
    ("> em" . "// ")
    ("> i" . "// ")
    ("> u" . "__ ")
    ("> s" . "-> ")
    ;; inside-blockquote-li
    ("> - p" . "~&")
    ("> - strong" . "** ")
    ("> - b" . "** ")
    ("> - em" . "// ")
    ("> - i" . "// ")
    ("> - u" . "__ ")
    ("> - s" . "-> ")))

(defparameter *important-attributes*
  '("data-language" "src"))

(defvar *inside-blockquote-p* nil)

(defun inside-blockquote-p (node)
  (or (string= "blockquote" (plump:tag-name node))
      *inside-blockquote-p*))

(defvar *inside-li-p* nil)

(defun inside-li-p (node)
  (or (string= "li" (plump:tag-name node))
      *inside-li-p*))

(defun translate-string (string tag-case)
  (let ((tag (concatenate 'string
                          (if *inside-blockquote-p* "> " "")
                          (if *inside-li-p* "- ")
                          string))
        (place (case tag-case
                 (:open *open-tag*)
                 (:close *close-tag*)
                 (otherwise nil))))
    (format *stream* (or (rest (assoc tag place :test 'string=)) ""))))

(defun filter-attribute (key value)
  (cond ((string= "src" key) (format nil "~A" value))
        ((string= "data-language" key) (format nil "~A~&" value))
        (t nil)))

(defun output-markless (node &optional (stream t))
  (cond ((eql stream t)
         (let ((*stream* *standard-output*))
           (element-lossy-markless node)))
        ((eql stream nil)
         (with-output-to-string (*stream*)
           (element-lossy-markless node)))
        (t
         (let ((*stream* stream))
           (element-lossy-markless node)))))

;;;
;;; Reference from plump:serialize-object
;;; --------------------------------------------
;;; Why lossy? (:ref element-lossy-markless)
;;; Because there are loss data after converted.
;;; --------------------------------------------

(defmethod element-lossy-markless ((node plump:text-node))
  (plump:encode-entities (plump:render-text node) *stream*))
(defmethod element-lossy-markless ((node plump:doctype)))
(defmethod element-lossy-markless ((node plump:comment)))
(defmethod element-lossy-markless ((node plump:element))
  (translate-string (plump:tag-name node) :open)
  (element-lossy-markless (plump:attributes node))
  (when (and (< 0 (length (plump:children node)))
             (string/= "audio" (plump:tag-name node))
             (string/= "video" (plump:tag-name node)))
    (loop with *inside-blockquote-p* = (inside-blockquote-p node)
          and *inside-li-p* = (inside-li-p node)
          for child across (plump:children node)
          do (element-lossy-markless child)))
  (translate-string (plump:tag-name node) :close))
(defmethod element-lossy-markless ((node plump:fulltext-element)))
(defmethod element-lossy-markless ((node plump:xml-header)))
(defmethod element-lossy-markless ((node plump:cdata)))
(defmethod element-lossy-markless ((node plump:processing-instruction)))
(defmethod element-lossy-markless ((table hash-table))
  ;; Important for tags like code, img, audio, video.
  (let ((attributes (loop for key being the hash-keys of table
                          for val being the hash-values of table
                          when (member key *important-attributes*
                                       :test 'string=)
                            collect (filter-attribute key val))))
    (format *stream* "~@[~{~A~^ ~}~]" attributes)))
(defmethod element-lossy-markless ((node plump:nesting-node))
  (loop for child across (plump:children node)
        do (element-lossy-markless child)))
(defmethod element-lossy-markless ((nodes vector))
  (loop for child across nodes
        do (element-lossy-markless child)))
